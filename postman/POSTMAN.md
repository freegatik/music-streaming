# Инструкция по работе с Postman коллекцией

Полная инструкция для работы с API через Postman. Коллекция содержит все эндпоинты с примерами запросов и автоматической настройкой JWT авторизации.

## Импорт и настройка

1. Открой Postman
2. Нажми Import (Cmd+O / Ctrl+O)
3. Выбери файл `postman/music-streaming-api.postman_collection.json`
4. Коллекция появится в списке слева

После импорта настрой переменные коллекции:

1. Кликни правой кнопкой на коллекцию "Music Streaming API" → Edit
2. Перейди на вкладку Variables
3. Заполни:
   - `baseUrl` = `http://localhost:8081`
   - `username` = (заполнишь после регистрации)
   - `password` = (заполнишь после регистрации)

Переменные `userId`, `playlistId`, `accessToken` и `refreshToken` устанавливаются автоматически при выполнении запросов.

## Как работает авторизация

Приложение использует JWT токены для авторизации. Есть два типа токенов:
- **Access токен** - живёт 15 минут, используется для доступа к защищённым эндпоинтам
- **Refresh токен** - живёт 7 дней, используется для получения новой пары токенов

Коллекция настроена так, что все защищённые запросы автоматически используют Bearer токен из переменной `{{accessToken}}`. Если токена нет, используется Basic Auth как fallback (для обратной совместимости).

## Начало работы

### 1. Регистрация

**Запрос:** Authentication → Register User

Тело запроса:
```json
{
    "username": "testuser",
    "password": "Test123!@#",
    "email": "testuser@example.com",
    "firstName": "Test",
    "lastName": "User"
}
```

Ожидаемо: статус 201, данные пользователя без пароля. Переменные `userId` и `username` сохраняются автоматически.

После регистрации заполни `username` и `password` в переменных коллекции вручную, если они не установились.

**Валидация пароля:**
Пароль должен быть минимум 8 символов, содержать хотя бы одну цифру, одну букву и один спецсимвол. Нельзя создать пользователя с одинаковым username или email.

### 2. Получение токенов (Login)

**Запрос:** Authentication → Login

Тело запроса:
```json
{
    "username": "{{username}}",
    "password": "{{password}}"
}
```

Ожидаемо: статус 200, в ответе `accessToken` и `refreshToken`. Оба токена автоматически сохраняются в переменные коллекции.

Проверить можно в Variables коллекции - там должны появиться `accessToken` и `refreshToken`.

### 3. Использование Access токена

После Login все защищённые запросы автоматически используют Bearer токен. Попробуй любой защищённый эндпоинт, например:

**Запрос:** Users → Get User by ID

Ожидаемо: статус 200, данные пользователя. Это подтверждает, что JWT фильтр работает.

Для проверки без токена: удали переменную `accessToken` или установи пустое значение. Запрос должен вернуть 401.

### 4. Обновление токенов (Refresh)

**Запрос:** Authentication → Refresh Token

Тело запроса:
```json
{
    "refreshToken": "{{refreshToken}}"
}
```

Ожидаемо: статус 200, новая пара токенов. Переменные обновляются автоматически.

После refresh старый access токен перестаёт работать. Новый access токен должен работать - проверь тем же запросом, что в шаге 3.

### 5. Проверка защиты от повторного использования

Важно: сначала выполни шаг 4 (refresh), чтобы получить новую пару токенов.

**Запрос:** Authentication → Refresh Token

Как проверить:
1. Перед refresh скопируй значение `{{refreshToken}}` из Variables
2. Выполни refresh - получишь новую пару токенов
3. Вставь сохранённый старый refresh токен в тело запроса
4. Выполни запрос снова

Ожидаемо: статус 401, сообщение "Обнаружена попытка повторного использования refresh токена". Старый refresh токен не должен работать повторно - это защита от replay-атак.

## Публичные эндпоинты

Всё нижеперечисленное работает без авторизации:

**Артисты:**
- Get All Artists
- Get Artist by ID
- Search Artists
- Get Artists by Country

**Альбомы:**
- Get All Albums
- Get Album by ID
- Get Albums by Artist
- Search Albums

**Треки:**
- Get All Tracks
- Get Track by ID
- Get Tracks by Artist
- Get Tracks by Album
- Get Tracks by Genre
- Search Tracks

**Плейлисты:**
- Get Public Playlists

## CRUD операции

### Каталог (только ADMIN)

Обычный пользователь с ролью USER не имеет доступа к созданию/изменению/удалению артистов, альбомов и треков. Все эти запросы возвращают 403:

- Create Artist (ADMIN)
- Update Artist (ADMIN)
- Delete Artist (ADMIN)
- Create Album (ADMIN)
- Update Album (ADMIN)
- Delete Album (ADMIN)
- Create Track (ADMIN)
- Update Track (ADMIN)
- Delete Track (ADMIN)

Для проверки ADMIN операций нужна роль ADMIN. По умолчанию все новые пользователи регистрируются с ролью USER.

### Плейлисты

**Создание:** Create Playlist создаёт плейлист автоматически для текущего пользователя. Владелец устанавливается автоматически. Переменная `playlistId` сохраняется автоматически.

**Просмотр:**
- Get All Playlists - список всех плейлистов
- Get Playlist by ID - детали плейлиста
- Get Playlists by User - плейлисты конкретного пользователя
- Search Playlists - поиск по имени
- Get Playlist Tracks - треки в плейлисте

**Изменение и удаление:** Пользователь может изменять и удалять только свои плейлисты. Попытка изменить или удалить чужой плейлист вернёт 403.

**Треки в плейлисте:**
- Add Track to Playlist - добавление трека (можно указать позицию через параметр `position`)
- Remove Track from Playlist - удаление трека по позиции
- Move Track in Playlist - перестановка трека на другую позицию
- Shuffle Playlist - перемешивание треков

Все операции доступны только владельцу плейлиста.

**Клонирование:**
- Clone Playlist - создаёт копию плейлиста для текущего пользователя. Можно клонировать публичные плейлисты или свои. Приватные чужие плейлисты клонировать нельзя (403).

### Пользователи

**Список всех пользователей** (Get All Users) доступен только ADMIN. USER получит 403.

**Получение по ID** (Get User by ID): пользователь может увидеть только свои данные. Чужие вернут 403.

**Изменение и удаление:** Можно менять и удалять только свой аккаунт.

**Статистика** (Get User Summary): возвращает статистику по библиотеке - сколько плейлистов, треков, уникальных артистов. Просмотр доступен только для своего аккаунта (кроме ADMIN).

**Daily Mix** (Create Daily Mix): создаёт плейлист из треков, которые есть в других плейлистах пользователя. Можно указать жанр и лимит. Генерировать микс можно только для себя.

## Бизнес-операции

### Перестановка трека

**Запрос:** Playlists → Move Track in Playlist

Тело:
```json
{
    "trackId": 1,
    "newPosition": 0
}
```

Трек перемещается на указанную позицию, остальные треки сдвигаются. Возвращается обновлённый список треков плейлиста.

### Перемешивание

**Запрос:** Playlists → Shuffle Playlist

Перемешивает треки в плейлисте случайным образом. Позиции должны быть последовательными (0, 1, 2...), все треки остаются в плейлисте.

### Клонирование

**Запрос:** Playlists → Clone Playlist

Тело:
```json
{
    "name": "Cloned Playlist",
    "description": "Cloned from original",
    "makePublic": false
}
```

Создаёт копию плейлиста для текущего пользователя. Треки копируются с теми же позициями.

### Daily Mix

**Запрос:** Users → Create Daily Mix

Тело:
```json
{
    "name": "Daily Mix",
    "description": "Auto-generated mix",
    "genre": "Indie",
    "limit": 10,
    "makePublic": false
}
```

Создаёт плейлист из треков, которые есть в других плейлистах пользователя. Если указан жанр, выбираются треки этого жанра.

## Полный сценарий для демонстрации

Для проверки работы всего функционала:

1. **Регистрация** → Authentication → Register User
2. **Логин** → Authentication → Login → токены сохраняются автоматически
3. **Использование access токена** → Users → Get User by ID → должен работать
4. **Просмотр каталога** → Artists/Albums/Tracks → Get All (публичные эндпоинты)
5. **Создание плейлиста** → Playlists → Create Playlist
6. **Добавление треков** → Playlists → Add Track to Playlist
7. **Перестановка треков** → Playlists → Move Track in Playlist
8. **Перемешивание** → Playlists → Shuffle Playlist
9. **Клонирование** → Playlists → Clone Playlist
10. **Daily Mix** → Users → Create Daily Mix
11. **Статистика** → Users → Get User Summary
12. **Refresh токенов** → Authentication → Refresh Token → новая пара токенов
13. **Повторное использование старого refresh** → Authentication → Refresh Token со старым токеном → должен вернуть 401
14. **Проверка доступа к чужим данным** → попробуй изменить чужой плейлист или получить данные другого пользователя → должен вернуть 403

## Типичные ошибки

**401 Unauthorized:**
- Токен истёк (access токен живёт 15 минут)
- Токен невалидный
- Переменная `accessToken` не установлена
- Refresh токен уже использован или истёк

**403 Forbidden:**
- Не хватает прав (USER пытается делать ADMIN операции)
- Попытка изменить чужой плейлист или получить чужие данные
- Токен валиден, но нет прав на операцию

**400 Bad Request:**
- Ошибка валидации (проверь формат данных в теле запроса)
- Пароль не соответствует требованиям
- Дубликат username или email

**404 Not Found:**
- Эндпоинт не найден или неправильный ID в пути

## Структура коллекции

Запросы разбиты по папкам:

- **Authentication** - регистрация, логин, refresh токенов
- **Artists** - работа с артистами (GET - публичный, POST/PUT/DELETE - ADMIN)
- **Albums** - работа с альбомами (GET - публичный, POST/PUT/DELETE - ADMIN)
- **Tracks** - работа с треками (GET - публичный, POST/PUT/DELETE - ADMIN)
- **Playlists** - работа с плейлистами (нужна авторизация, USER может управлять только своими)
- **Users** - операции с пользователями (USER видит только себя, ADMIN - всех)

## Полезные фичи

- Переменные `{{userId}}`, `{{playlistId}}`, `{{accessToken}}` и `{{refreshToken}}` автоматически заполняются после соответствующих операций
- Все запросы используют переменные коллекции, так что можно быстро менять базовый URL
- Коллекция автоматически использует Bearer токен, если он есть, иначе Basic Auth
- В коллекции есть и публичные запросы (они помечены как noauth), и защищённые (используют JWT)

## Примеры ответов

**Успешная регистрация (201):**
```json
{
    "id": 1,
    "username": "testuser",
    "email": "testuser@example.com",
    "firstName": "Test",
    "lastName": "User"
}
```

**Успешный логин (200):**
```json
{
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**Ошибка доступа (403):**
```json
{
    "timestamp": "2024-01-01T12:00:00",
    "status": 403,
    "error": "Доступ запрещён",
    "message": "У вас нет прав для выполнения этого действия"
}
```

**Ошибка токена (401):**
```json
{
    "timestamp": "2024-01-01T12:00:00",
    "status": 401,
    "error": "Ошибка токена",
    "message": "Обнаружена попытка повторного использования refresh токена"
}
```

Если что-то не понятно - смотри примеры в запросах или запускай их по очереди, чтобы понять как работает API.
